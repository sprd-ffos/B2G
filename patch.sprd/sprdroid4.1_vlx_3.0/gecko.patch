diff --git a/b2g/app/BootAnimation.cpp b/b2g/app/BootAnimation.cpp
index 5945ebe..a3f9d34 100644
--- a/b2g/app/BootAnimation.cpp
+++ b/b2g/app/BootAnimation.cpp
@@ -542,7 +542,7 @@ NativeWindow()
     if (gNativeWindow.get()) {
         return gNativeWindow.get();
     }
-
+#if ANDROID_VERSION < 16
     // Some gralloc HALs need this in order to open the
     // framebuffer device after we restart with the screen off.
     //
@@ -550,7 +550,9 @@ NativeWindow()
     // FramebufferNativeWindow.  Do not separate these two C++
     // statements.
     set_screen_state(1);
-
+#else
+#warning Not sure what to do!  Does not seem to be necessary.
+#endif
     // For some devices, it takes a while for the framebuffer to become
     // usable. So we wait until the framebuffer has woken up before we
     // try to open it.
diff --git a/configure.in b/configure.in
index cad03c2..dca9f49 100644
--- a/configure.in
+++ b/configure.in
@@ -200,6 +200,13 @@ if test -n "$gonkdir" ; then
     esac
 
     CPPFLAGS="-DANDROID -isystem $gonkdir/bionic/libc/$ARCH_DIR/include -isystem $gonkdir/bionic/libc/include/ -isystem $gonkdir/bionic/libc/kernel/common -isystem $gonkdir/bionic/libc/kernel/$ARCH_DIR -isystem $gonkdir/bionic/libm/include -I$gonkdir/frameworks/base/opengl/include -I$gonkdir/frameworks/base/native/include -I$gonkdir/hardware/libhardware/include -I$gonkdir/hardware/libhardware_legacy/include -I$gonkdir/system -I$gonkdir/system/core/include -isystem $gonkdir/bionic -I$gonkdir/frameworks/base/include -I$gonkdir/external/dbus -I$gonkdir/external/bluetooth/bluez/lib $CPPFLAGS -I$gonkdir/frameworks/base/services/sensorservice -I$gonkdir/frameworks/base/services/camera -I$gonkdir/system/media/wilhelm/include -I$gonkdir/frameworks/base/include/media/stagefright -I$gonkdir/frameworks/base/include/media/stagefright/openmax -I$gonkdir/frameworks/base/media/libstagefright/rtsp -I$gonkdir/frameworks/base/media/libstagefright/include -I$gonkdir/dalvik/libnativehelper/include/nativehelper"
+    # the actual version we're building for
+    ANDROID_VERSION=16
+    # the version of the prebuilt stuff, which may be lower than ANDROID_VERSION
+    PREBUILT_ANDROID_VERSION=14
+    PREBUILD_NDK_VERSION=7
+    CPPFLAGS="$CPPFLAGS -isystem $gonkdir/prebuilts/ndk/android-ndk-r$PREBUILD_NDK_VERSION/platforms/android-$PREBUILT_ANDROID_VERSION/$ARCH_DIR/usr/include \
+-I$gonkdir/frameworks/native/include -I$gonkdir/frameworks/native/include/media -I$gonkdir/frameworks/native/include/media/hardware -I$gonkdir/frameworks/native/include/media/openmax -I$gonkdir/frameworks/native/opengl/include -I$gonkdir/frameworks/native/include/gui -I$gonkdir/frameworks/av/include -I$gonkdir/external/dbus -I$gonkdir/frameworks/av/services/camera/ -I$gonkdir/frameworks/av/include/media -I$gonkdir/frameworks/av/include/media/stagefright -I$gonkdir/frameworks/av/media/libstagefright/rtsp -I$gonkdir/frameworks/av/media/libstagefright/include"
     CFLAGS="-mandroid -fno-short-enums -fno-exceptions $CFLAGS"
     CXXFLAGS="-mandroid -fno-short-enums -fno-exceptions -Wno-psabi $CXXFLAGS $STLPORT_CPPFLAGS"
     dnl Add -llog by default, since we use it all over the place.
@@ -222,6 +229,8 @@ if test -n "$gonkdir" ; then
     fi
 
     AC_DEFINE(ANDROID)
+    AC_DEFINE_UNQUOTED(ANDROID_VERSION, $ANDROID_VERSION)
+    AC_SUBST(ANDROID_VERSION)
     AC_DEFINE(HAVE_SYS_UIO_H)
     AC_DEFINE(HAVE_PTHREADS)
     CROSS_COMPILE=1
diff --git a/content/media/ogg/nsOggCodecState.cpp b/content/media/ogg/nsOggCodecState.cpp
index a712772..a97c2d7 100644
--- a/content/media/ogg/nsOggCodecState.cpp
+++ b/content/media/ogg/nsOggCodecState.cpp
@@ -351,7 +351,9 @@ nsTheoraState::IsHeader(ogg_packet* aPacket) {
   return th_packet_isheader(aPacket);
 }
 
-# define TH_VERSION_CHECK(_info,_maj,_min,_sub) \
+#undef version_major
+#undef version_minor
+#define TH_VERSION_CHECK(_info,_maj,_min,_sub) \
  (((_info)->version_major>(_maj)||(_info)->version_major==(_maj))&& \
  (((_info)->version_minor>(_min)||(_info)->version_minor==(_min))&& \
  (_info)->version_subminor>=(_sub)))
diff --git a/dom/camera/AudioParameter.cpp b/dom/camera/AudioParameter.cpp
index 59ccfd0..e4c4598 100644
--- a/dom/camera/AudioParameter.cpp
+++ b/dom/camera/AudioParameter.cpp
@@ -17,18 +17,30 @@
 #define LOG_TAG "AudioParameter"
 //#define LOG_NDEBUG 0
 
-#include <utils/Log.h>
-
 #include <media/AudioParameter.h>
 
+#define DOM_CAMERA_LOG_LEVEL        3
+#include "CameraCommon.h"
+#define LOGD DOM_CAMERA_LOGA
+#define LOGV DOM_CAMERA_LOGI
+#define LOGI DOM_CAMERA_LOGI
+#define LOGW DOM_CAMERA_LOGW
+#define LOGE DOM_CAMERA_LOGE
+
 namespace android {
 
-const char *AudioParameter::keyRouting = "routing";
-const char *AudioParameter::keySamplingRate = "sampling_rate";
-const char *AudioParameter::keyFormat = "format";
-const char *AudioParameter::keyChannels = "channels";
-const char *AudioParameter::keyFrameCount = "frame_count";
-const char *AudioParameter::keyInputSource = "input_source";
+#if ANDROID_VERSION >= 16
+#define EXTRA_CONST const
+#else
+#define EXTRA_CONST
+#endif
+
+const char * EXTRA_CONST AudioParameter::keyRouting = "routing";
+const char * EXTRA_CONST AudioParameter::keySamplingRate = "sampling_rate";
+const char * EXTRA_CONST AudioParameter::keyFormat = "format";
+const char * EXTRA_CONST AudioParameter::keyChannels = "channels";
+const char * EXTRA_CONST AudioParameter::keyFrameCount = "frame_count";
+const char * EXTRA_CONST AudioParameter::keyInputSource = "input_source";
 
 AudioParameter::AudioParameter(const String8& keyValuePairs)
 {
diff --git a/dom/camera/CameraCommon.h b/dom/camera/CameraCommon.h
index ef5c56b..1f5887d 100644
--- a/dom/camera/CameraCommon.h
+++ b/dom/camera/CameraCommon.h
@@ -23,6 +23,12 @@
 #include "nsIDOMCameraManager.h"
 #include "prlog.h"
 
+#if ANDROID_VERSION >= 16
+#include <mozilla/Assertions.h>
+#define CHECK_EQ(a,b)  MOZ_ASSERT((a) == (b), "failed")
+#define CHECK(a)       MOZ_ASSERT((a), "failed")
+#endif
+
 #ifdef PR_LOGGING
 extern PRLogModuleInfo* gCameraLog;
 #define DOM_CAMERA_LOG( type, ... ) PR_LOG(gCameraLog, (PRLogModuleLevel)type, ( __VA_ARGS__ ))
diff --git a/dom/camera/GonkCameraSource.cpp b/dom/camera/GonkCameraSource.cpp
index 7ed3c35..64359be 100644
--- a/dom/camera/GonkCameraSource.cpp
+++ b/dom/camera/GonkCameraSource.cpp
@@ -28,7 +28,9 @@
 #include "GonkCameraSource.h"
 #include "GonkCameraListener.h"
 #include "GonkCameraHwMgr.h"
+#if ANDROID_VERSION < 16
 #include <media/stagefright/MediaDebug.h>
+#endif
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/MetaData.h>
@@ -677,7 +679,7 @@ status_t GonkCameraSource::read(
 
  
 	//aoke add from camerasource to get physical address @sprd 
-	 if (mOMXRunLocally) {
+	 if (true) {
 	     int32_t phy_addr;
 	     ssize_t offset = 0;
     	     size_t size = 0;
diff --git a/dom/camera/GonkNativeWindow.cpp b/dom/camera/GonkNativeWindow.cpp
index 7a99798..4875d97 100644
--- a/dom/camera/GonkNativeWindow.cpp
+++ b/dom/camera/GonkNativeWindow.cpp
@@ -478,6 +478,16 @@ status_t GonkNativeWindow::queueBuffer(int buf, int64_t timestamp,
     return OK;
 }
 
+status_t GonkNativeWindow::queueBuffer(int slot,
+            const QueueBufferInput& input, QueueBufferOutput* output) {
+//Empty implementation
+	return OK;
+}
+
+status_t GonkNativeWindow::connect(int api, QueueBufferOutput* output) {
+//Empty implementation
+	return OK;
+}
 
 already_AddRefed<GraphicBufferLocked>
 GonkNativeWindow::getCurrentBuffer()
diff --git a/dom/camera/GonkNativeWindow.h b/dom/camera/GonkNativeWindow.h
index f402bf9..cfff158 100644
--- a/dom/camera/GonkNativeWindow.h
+++ b/dom/camera/GonkNativeWindow.h
@@ -22,7 +22,11 @@
 #include <sys/types.h>
 
 #include <gui/ISurfaceTexture.h>
+#if ANDROID_VERSION < 16
 #include <ui/egl/android_natives.h>
+#else
+#include <ui/ANativeObjectBase.h>
+#endif
 #include <ui/GraphicBuffer.h>
 #include <ui/Rect.h>
 #include <utils/Errors.h>
@@ -92,6 +96,11 @@ public:
     // client.
     virtual status_t queueBuffer(int buf, int64_t timestamp,
             uint32_t* outWidth, uint32_t* outHeight, uint32_t* outTransform);
+
+    virtual status_t queueBuffer(int slot,
+            const QueueBufferInput& input, QueueBufferOutput* output);
+    virtual status_t connect(int api, QueueBufferOutput* output);
+
     virtual void cancelBuffer(int buf);
     virtual status_t setCrop(const Rect& reg);
     virtual status_t setTransform(uint32_t transform);
diff --git a/dom/camera/GonkNativeWindowClient.h b/dom/camera/GonkNativeWindowClient.h
index c7b7ba3..dab79c9 100644
--- a/dom/camera/GonkNativeWindowClient.h
+++ b/dom/camera/GonkNativeWindowClient.h
@@ -17,14 +17,20 @@
 
 #ifndef DOM_CAMERA_GONKNATIVEWINDOWCLIENT_H
 #define DOM_CAMERA_GONKNATIVEWINDOWCLIENT_H
-
+#if ANDROID_VERSION < 16
 #include <ui/egl/android_natives.h>
-
+#else
+#include <ui/ANativeObjectBase.h>
+#endif
 #include "GonkNativeWindow.h"
 
 namespace android {
 
-class GonkNativeWindowClient : public EGLNativeBase<ANativeWindow, GonkNativeWindowClient, RefBase>
+#if ANDROID_VERSION < 16
+class GonkNativeWindowClient : public EGLNativeBase<ANativeWindow, GonkNativeWindowClient,, RefBase>
+#else
+class GonkNativeWindowClient : public ANativeObjectBase<ANativeWindow, GonkNativeWindowClient, RefBase>
+#endif
 {
 public:
     GonkNativeWindowClient(const sp<GonkNativeWindow>& window);
diff --git a/dom/camera/GonkRecorder.cpp b/dom/camera/GonkRecorder.cpp
index 1ee2899..17eb8bb 100644
--- a/dom/camera/GonkRecorder.cpp
+++ b/dom/camera/GonkRecorder.cpp
@@ -23,7 +23,9 @@
 #include <media/stagefright/AMRWriter.h>
 #include <media/stagefright/MPEG2TSWriter.h>
 #include <media/stagefright/MPEG4Writer.h>
+#if ANDROID_VERSION < 16
 #include <media/stagefright/MediaDebug.h>
+#endif
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/OMXClient.h>
diff --git a/dom/system/gonk/AudioManager.cpp b/dom/system/gonk/AudioManager.cpp
index d585084..8119f58 100644
--- a/dom/system/gonk/AudioManager.cpp
+++ b/dom/system/gonk/AudioManager.cpp
@@ -54,9 +54,36 @@ static int sMaxStreamVolumeTbl[AUDIO_STREAM_CNT] = {
 static int sHeadsetState;
 static int kBtSampleRate = 8000;
 
+#if ANDROID_VERSION >= 16
+audio_devices_t getDeviceForStream(audio_stream_type_t stream) {
+  int32_t device = AudioSystem::getDevicesForStream(stream);
+  if ((device & (device - 1)) != 0) {
+    // Multiple device selection is either:
+    //  - speaker + one other device: give priority to speaker in this case.
+    //  - one A2DP device + another device: happens with duplicated output. In this case
+    // retain the device on the A2DP output as the other must not correspond to an active
+    // selection if not the speaker.
+    if ((device & AUDIO_DEVICE_OUT_SPEAKER) != 0) {
+      device = AUDIO_DEVICE_OUT_SPEAKER;
+    } else {
+      device &= AUDIO_DEVICE_OUT_ALL_A2DP;
+    }
+  }
+  
+  if (stream == AUDIO_STREAM_FM && device == 0) {
+    return AUDIO_DEVICE_OUT_FM_HEADSET;
+  }
+  return (audio_devices_t)device;
+}
+#endif
+
 static bool
 IsDeviceOn(audio_devices_t device)
 {
+#if ANDROID_VERSION >= 16
+  return AudioSystem::getDeviceConnectionState(device, "") ==
+      AUDIO_POLICY_DEVICE_STATE_AVAILABLE;
+#else
   if (static_cast<
       audio_policy_dev_state_t (*) (audio_devices_t, const char *)
       >(AudioSystem::getDeviceConnectionState))
@@ -64,6 +91,7 @@ IsDeviceOn(audio_devices_t device)
            AUDIO_POLICY_DEVICE_STATE_AVAILABLE;
 
   return false;
+#endif
 }
 
 NS_IMPL_ISUPPORTS2(AudioManager, nsIAudioManager, nsIObserver)
@@ -109,6 +137,7 @@ InternalSetAudioRoutesICS(SwitchState aState)
   }
 }
 
+#if ANDROID_VERSION < 16
 static void
 InternalSetAudioRoutesGB(SwitchState aState)
 {
@@ -124,10 +153,14 @@ InternalSetAudioRoutesGB(SwitchState aState)
 
   AudioSystem::setParameters(handle, cmd);
 }
+#endif
 
 static void
 InternalSetAudioRoutes(SwitchState aState)
 {
+#if ANDROID_VERSION >= 16
+  InternalSetAudioRoutesICS(aState);
+#else
   if (static_cast<
     status_t (*)(audio_devices_t, audio_policy_dev_state_t, const char*)
     >(AudioSystem::setDeviceConnectionState)) {
@@ -137,6 +170,7 @@ InternalSetAudioRoutes(SwitchState aState)
     >(AudioSystem::getOutput)) {
     InternalSetAudioRoutesGB(aState);
   }
+#endif
 }
 
 nsresult
@@ -214,9 +248,16 @@ AudioManager::AudioManager() : mPhoneState(PHONE_STATE_CURRENT),
     AudioSystem::initStreamVolume(static_cast<audio_stream_type_t>(loop), 0,
                                   sMaxStreamVolumeTbl[loop]);
   }
+#if ANDROID_VERSION < 16
   // Force publicnotification to output at maximal volume
   AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_ENFORCED_AUDIBLE),
                                     sMaxStreamVolumeTbl[AUDIO_STREAM_ENFORCED_AUDIBLE]);
+#else
+ // Force publicnotification to output at maximal volume
+ AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_ENFORCED_AUDIBLE),
+                                    sMaxStreamVolumeTbl[AUDIO_STREAM_ENFORCED_AUDIBLE],
+                                    getDeviceForStream(AUDIO_STREAM_ENFORCED_AUDIBLE) );
+#endif
 }
 
 AudioManager::~AudioManager() {
@@ -306,7 +347,7 @@ AudioManager::SetPhoneState(int32_t aState)
     return NS_OK;
   }
 
-  if (AudioSystem::setPhoneState(aState)) {
+  if (AudioSystem::setPhoneState(static_cast<audio_mode_t>(aState))) {
     return NS_ERROR_FAILURE;
   }
 
@@ -354,6 +395,10 @@ AudioManager::SetForceForUse(int32_t aUsage, int32_t aForce)
     aForce = nsIAudioManager::FORCE_BT_SCO;
   }
 
+#if ANDROID_VERSION >= 16
+  status = AudioSystem::setForceUse((audio_policy_force_use_t)aUsage,
+                                    (audio_policy_forced_cfg_t)aForce);
+#else
   if (static_cast<
       status_t (*)(AudioSystem::force_use, AudioSystem::forced_config)
       >(AudioSystem::setForceUse)) {
@@ -367,12 +412,16 @@ AudioManager::SetForceForUse(int32_t aUsage, int32_t aForce)
     status = AudioSystem::setForceUse((audio_policy_force_use_t)aUsage,
                                       (audio_policy_forced_cfg_t)aForce);
   }
+#endif
 
   return status ? NS_ERROR_FAILURE : NS_OK;
 }
 
 NS_IMETHODIMP
 AudioManager::GetForceForUse(int32_t aUsage, int32_t* aForce) {
+#if ANDROID_VERSION >= 16
+    *aForce = AudioSystem::getForceUse((audio_policy_force_use_t)aUsage);
+#else
   if (static_cast<
       AudioSystem::forced_config (*)(AudioSystem::force_use)
       >(AudioSystem::getForceUse)) {
@@ -384,6 +433,7 @@ AudioManager::GetForceForUse(int32_t aUsage, int32_t* aForce) {
     // Dynamically resolved the ICS signature.
     *aForce = AudioSystem::getForceUse((audio_policy_force_use_t)aUsage);
   }
+#endif
   return NS_OK;
 }
 
@@ -397,9 +447,12 @@ AudioManager::GetFmRadioAudioEnabled(bool *aFmRadioAudioEnabled)
 NS_IMETHODIMP
 AudioManager::SetFmRadioAudioEnabled(bool aFmRadioAudioEnabled)
 {
+#if ANDROID_VERSION < 16
   if (static_cast<
       status_t (*) (AudioSystem::audio_devices, AudioSystem::device_connection_state, const char *)
-      >(AudioSystem::setDeviceConnectionState)) {
+      >(AudioSystem::setDeviceConnectionState)) 
+#endif
+{
     AudioSystem::setDeviceConnectionState(AUDIO_DEVICE_OUT_FM,
       aFmRadioAudioEnabled ? AUDIO_POLICY_DEVICE_STATE_AVAILABLE :
       AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE, "");
@@ -407,27 +460,36 @@ AudioManager::SetFmRadioAudioEnabled(bool aFmRadioAudioEnabled)
     // sync volume with music after powering on fm radio
     if (aFmRadioAudioEnabled) {
       int32_t volIndex = 0;
+#if ANDROID_VERSION < 16
       AudioSystem::getStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_MUSIC), &volIndex);
       AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_FM), volIndex);
+#else
+      AudioSystem::getStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_MUSIC), &volIndex,getDeviceForStream(AUDIO_STREAM_MUSIC));
+      AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_FM), volIndex,getDeviceForStream(AUDIO_STREAM_FM));
+#endif
     }
     return NS_OK;
-  } else {
-    return NS_ERROR_NOT_IMPLEMENTED;
   }
+
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 AudioManager::SetStreamVolumeIndex(int32_t aStream, int32_t aIndex) {
   status_t status =
+#if ANDROID_VERSION < 16
     AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(aStream), aIndex);
+#else
+    AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(aStream), aIndex,getDeviceForStream( static_cast<audio_stream_type_t>(aStream) ) );
+#endif
 
-  // sync the fm stream volume with music volume, except set fm volume by audioChannelServices
-  if (aStream == AUDIO_STREAM_FM && IsDeviceOn(AUDIO_DEVICE_OUT_FM)) {
-    mFMChannelIsMuted = aIndex == 0;
-  }
   // sync fm volume with music stream type
-  if (aStream == AUDIO_STREAM_MUSIC && IsDeviceOn(AUDIO_DEVICE_OUT_FM) && !mFMChannelIsMuted) {
+  if (aStream == AUDIO_STREAM_MUSIC && IsDeviceOn(AUDIO_DEVICE_OUT_FM)) {
+#if ANDROID_VERSION < 16
     AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_FM), aIndex);
+#else
+    AudioSystem::setStreamVolumeIndex(static_cast<audio_stream_type_t>(AUDIO_STREAM_FM), aIndex,getDeviceForStream(AUDIO_STREAM_FM));
+#endif
   }
 
   return status ? NS_ERROR_FAILURE : NS_OK;
@@ -436,7 +498,11 @@ AudioManager::SetStreamVolumeIndex(int32_t aStream, int32_t aIndex) {
 NS_IMETHODIMP
 AudioManager::GetStreamVolumeIndex(int32_t aStream, int32_t* aIndex) {
   status_t status =
+#if ANDROID_VERSION < 16
     AudioSystem::getStreamVolumeIndex(static_cast<audio_stream_type_t>(aStream), aIndex);
+#else
+    AudioSystem::getStreamVolumeIndex(static_cast<audio_stream_type_t>(aStream), aIndex,getDeviceForStream( static_cast<audio_stream_type_t>(aStream) ) );
+#endif
   return status ? NS_ERROR_FAILURE : NS_OK;
 }
 
diff --git a/dom/system/gonk/VolumeCommand.h b/dom/system/gonk/VolumeCommand.h
index 58c9733..5886f60 100644
--- a/dom/system/gonk/VolumeCommand.h
+++ b/dom/system/gonk/VolumeCommand.h
@@ -104,7 +104,8 @@ class VolumeCommand : public RefCounted<VolumeCommand>
 public:
   VolumeCommand(VolumeResponseCallback* aCallback)
     : mBytesConsumed(0),
-      mCallback(aCallback)
+      mCallback(aCallback),
+      mSequenceNumber(0)
   {
     SetCmd(NS_LITERAL_CSTRING(""));
   }
@@ -120,7 +121,11 @@ public:
 
   void SetCmd(const nsACString& aCommand)
   {
-    mCmd = aCommand;
+    //FrameworkListener need to be start seqnum
+    mSequenceNumber++;
+    mCmd.Append(NS_LITERAL_CSTRING("1 "));
+
+    mCmd.Append( aCommand );
     // Add a null character. We want this to be included in the length since
     // vold uses it to determine the end of the command.
     mCmd.Append('\0');
@@ -162,6 +167,7 @@ private:
 
   // Called when a response to the command is received.
   RefPtr<VolumeResponseCallback>  mCallback;
+  int    mSequenceNumber;//FrameworkListener need to be start seqnum
 };
 
 class VolumeActionCommand : public VolumeCommand
diff --git a/dom/system/gonk/VolumeManager.cpp b/dom/system/gonk/VolumeManager.cpp
index aceeba6..9db5d25 100644
--- a/dom/system/gonk/VolumeManager.cpp
+++ b/dom/system/gonk/VolumeManager.cpp
@@ -151,6 +151,7 @@ class VolumeListCallback : public VolumeResponseCallback
         // So for each volume that we get back, we update any volumes that
         // we have of the same name, or add new ones if they don't exist.
         nsCWhitespaceTokenizer tokenizer(ResponseStr());
+        tokenizer.nextToken();   //Android JB vold add seqNum for command
         nsDependentCSubstring volName(tokenizer.nextToken());
         RefPtr<Volume> vol = VolumeManager::FindAddVolumeByName(volName);
         vol->HandleVoldResponse(ResponseCode(), tokenizer);
diff --git a/dom/system/gonk/systemlibs.js b/dom/system/gonk/systemlibs.js
index 9c42da0..aae9748 100644
--- a/dom/system/gonk/systemlibs.js
+++ b/dom/system/gonk/systemlibs.js
@@ -201,6 +201,7 @@ this.libnetutils = (function () {
     let dns1buf = ctypes.char.array(4096)();
     let dns2buf = ctypes.char.array(4096)();
     let serverbuf = ctypes.char.array(4096)();
+    let vendorInfo = ctypes.char.array(4096)();
     let lease = ctypes.int();
     let c_dhcp_do_request =
       library.declare("dhcp_do_request", ctypes.default_abi,
@@ -212,7 +213,8 @@ this.libnetutils = (function () {
                       ctypes.char.ptr, // dns1
                       ctypes.char.ptr, // dns2
                       ctypes.char.ptr, // server
-                      ctypes.int.ptr); // lease
+                      ctypes.int.ptr, // lease
+                      ctypes.char.ptr); // vendorInfo
 
 
     iface.dhcp_do_request = function dhcp_do_request(ifname) {
@@ -223,7 +225,7 @@ this.libnetutils = (function () {
                                   dns1buf,
                                   dns2buf,
                                   serverbuf,
-                                  lease.address());
+                                  lease.address(), vendorInfo);
 
       if (ret && DEBUG) {
         let error = iface.dhcp_get_errmsg();
@@ -237,7 +239,8 @@ this.libnetutils = (function () {
         dns1_str: dns1buf.readString(),
         dns2_str: dns2buf.readString(),
         server_str: serverbuf.readString(),
-        lease: lease.value | 0
+        lease: lease.value | 0,
+        server_str: ""
       };
       obj.ipaddr = netHelpers.stringToIP(obj.ipaddr_str);
       obj.mask_str = netHelpers.ipToString(obj.mask);
@@ -246,6 +249,7 @@ this.libnetutils = (function () {
       obj.dns1 = netHelpers.stringToIP(obj.dns1_str);
       obj.dns2 = netHelpers.stringToIP(obj.dns2_str);
       obj.server = netHelpers.stringToIP(obj.server_str);
+      obj.vendorInfo = "";
       return obj;
     };
     // dhcp_do_request_renew() went away in newer libnetutils.
@@ -262,7 +266,7 @@ this.libnetutils = (function () {
       return c_ifc_reset_connections(ifname, reset_mask) | 0;
     }
   } else {
-    let ints = ctypes.int.array(8)();
+    let ints = ctypes.int.array(9)();
     let c_dhcp_do_request =
       library.declare("dhcp_do_request", ctypes.default_abi,
                       ctypes.int,      // return value
@@ -273,7 +277,8 @@ this.libnetutils = (function () {
                       ctypes.int.ptr,  // dns1
                       ctypes.int.ptr,  // dns2
                       ctypes.int.ptr,  // server
-                      ctypes.int.ptr); // lease
+                      ctypes.int.ptr, // lease
+                      ctypes.int.ptr);  // vendorInfo
     let c_dhcp_do_request_renew =
       library.declare("dhcp_do_request_renew", ctypes.default_abi,
                       ctypes.int,      // return value
@@ -295,7 +300,8 @@ this.libnetutils = (function () {
                        ints.addressOfElement(3),
                        ints.addressOfElement(4),
                        ints.addressOfElement(5),
-                       ints.addressOfElement(6));
+                       ints.addressOfElement(6),
+                       ints.addressOfElement(7));
         if (ret && DEBUG) {
           let error = iface.dhcp_get_errmsg();
           dump("dhcp_do_request_* failed - " + error.readString());
@@ -307,7 +313,8 @@ this.libnetutils = (function () {
                 dns1: ints[3] | 0,
                 dns2: ints[4] | 0,
                 server: ints[5] | 0,
-                lease: ints[6] | 0};
+                lease: ints[6] | 0,
+                vendorInfo: ints[7] | 0};
       };
     };
     iface.dhcp_do_request = wrapCFunc(c_dhcp_do_request);
diff --git a/dom/wifi/libhardware_legacy.js b/dom/wifi/libhardware_legacy.js
index b537b87..76f56fe 100644
--- a/dom/wifi/libhardware_legacy.js
+++ b/dom/wifi/libhardware_legacy.js
@@ -18,23 +18,23 @@ let libhardware_legacy = (function () {
     unload_driver: library.declare("wifi_unload_driver", ctypes.default_abi, ctypes.int),
 
     // Start supplicant, 0 on success, < 0 on failure.
-    start_supplicant: library.declare("wifi_start_supplicant", ctypes.default_abi, ctypes.int),
+    start_supplicant: library.declare("wifi_start_supplicant", ctypes.default_abi, ctypes.int, ctypes.int),
 
     // Stop supplicant, 0 on success, < 0 on failure.
     stop_supplicant: library.declare("wifi_stop_supplicant", ctypes.default_abi, ctypes.int),
 
     // Open a connection to the supplicant, 0 on success, < 0 on failure.
-    connect_to_supplicant: library.declare("wifi_connect_to_supplicant", ctypes.default_abi, ctypes.int),
+    connect_to_supplicant: library.declare("wifi_connect_to_supplicant", ctypes.default_abi, ctypes.int, ctypes.char.ptr),
 
     // Close connection to connection to the supplicant, 0 on success, < 0 on failure.
-    close_supplicant_connection: library.declare("wifi_close_supplicant_connection", ctypes.default_abi, ctypes.void_t),
+    close_supplicant_connection: library.declare("wifi_close_supplicant_connection", ctypes.default_abi, ctypes.void_t, ctypes.char.ptr),
 
     // Block until a wifi event is returned, buf is the buffer, len is the max length of the buffer.
     // Return value is number of bytes in buffer, or 0 if no event (no connection for instance), and < 0 on failure.
-    wait_for_event: library.declare("wifi_wait_for_event", ctypes.default_abi, ctypes.int, ctypes.char.ptr, ctypes.size_t),
+    wait_for_event: library.declare("wifi_wait_for_event", ctypes.default_abi, ctypes.int, ctypes.char.ptr, ctypes.char.ptr, ctypes.size_t),
 
     // Issue a command to the wifi driver. command is the command string, reply will hold the reply, reply_len contains
     // the maximum reply length initially and is updated with the actual length. 0 is returned on success, < 0 on failure.
-    command: library.declare("wifi_command", ctypes.default_abi, ctypes.int, ctypes.char.ptr, ctypes.char.ptr, ctypes.size_t.ptr),
+    command: library.declare("wifi_command", ctypes.default_abi, ctypes.int, ctypes.char.ptr, ctypes.char.ptr, ctypes.char.ptr, ctypes.size_t.ptr),
   };
 })();
diff --git a/dom/wifi/wifi_worker.js b/dom/wifi/wifi_worker.js
index f6bb430..2bc9c1d 100644
--- a/dom/wifi/wifi_worker.js
+++ b/dom/wifi/wifi_worker.js
@@ -42,7 +42,7 @@ self.onmessage = function(e) {
   switch (cmd) {
   case "command":
     len.value = 4096;
-    var ret = libhardware_legacy.command(data.request, cbuf, len.address());
+    var ret = libhardware_legacy.command("wlan0", data.request, cbuf, len.address());
     var reply = "";
     if (!ret) {
       // The return value from libhardware_legacy.command is not guaranteed to
@@ -67,7 +67,7 @@ self.onmessage = function(e) {
     postMessage({ id: id, status: ret, reply: reply });
     break;
   case "wait_for_event":
-    var ret = libhardware_legacy.wait_for_event(cbuf, 4096);
+    var ret = libhardware_legacy.wait_for_event("wlan0", cbuf, 4096);
     var event = cbuf.readString().substr(0, ret.value);
     postMessage({ id: id, event: event });
     break;
@@ -119,7 +119,18 @@ self.onmessage = function(e) {
     postMessage({ id: id, status: ret });
     break;
   case "close_supplicant_connection":
-    libhardware_legacy.close_supplicant_connection();
+    var ret = libhardware_legacy.close_supplicant_connection("wlan0");
+    debug("WIFI: close_supplicant_connection: " + ret + "\n");
+    postMessage({ id: id, status: ret });
+    break;
+  case "start_supplicant":
+    var ret = libhardware_legacy.start_supplicant(0);
+    debug("WIFI: start_supplicant: " + ret + "\n");
+    postMessage({ id: id, status: ret });
+    break;
+  case "connect_to_supplicant":
+    var ret = libhardware_legacy.connect_to_supplicant("wlan0");
+    debug("WIFI: connect_to_supplicant: " + ret + "\n");
     postMessage({ id: id, status: ret });
     break;
   default:
diff --git a/gfx/gl/GLContextProviderEGL.cpp b/gfx/gl/GLContextProviderEGL.cpp
index 91c501e..c8e2990 100644
--- a/gfx/gl/GLContextProviderEGL.cpp
+++ b/gfx/gl/GLContextProviderEGL.cpp
@@ -1364,7 +1364,7 @@ PixelFormatForImage(gfxASurface::gfxImageFormat aFormat)
     case gfxASurface::ImageFormatRGB16_565:
         return PIXEL_FORMAT_RGB_565;
     case gfxASurface::ImageFormatA8:
-        return PIXEL_FORMAT_L_8;
+        return PIXEL_FORMAT_A_8;
     default:
         MOZ_NOT_REACHED("Unknown gralloc pixel format for Image format");
     }
@@ -1375,7 +1375,7 @@ static gfxASurface::gfxContentType
 ContentTypeForPixelFormat(PixelFormat aFormat)
 {
     switch (aFormat) {
-    case PIXEL_FORMAT_L_8:
+    case PIXEL_FORMAT_A_8:
         return gfxASurface::CONTENT_ALPHA;
     case PIXEL_FORMAT_RGBA_8888:
         return gfxASurface::CONTENT_COLOR_ALPHA;
diff --git a/hal/gonk/GonkHal.cpp b/hal/gonk/GonkHal.cpp
index c5b0273..4484137 100644
--- a/hal/gonk/GonkHal.cpp
+++ b/hal/gonk/GonkHal.cpp
@@ -544,7 +544,11 @@ GetScreenEnabled()
 void
 SetScreenEnabled(bool enabled)
 {
+#if ANDROID_VERSION < 16
   set_screen_state(enabled);
+#else
+#warning Not sure what to do!  Does not seem to be necessary.
+#endif
   sScreenEnabled = enabled;
 }
 
diff --git a/media/libsydneyaudio/src/gonk/AudioSystem.h b/media/libsydneyaudio/src/gonk/AudioSystem.h
index f42a303..1793050 100644
--- a/media/libsydneyaudio/src/gonk/AudioSystem.h
+++ b/media/libsydneyaudio/src/gonk/AudioSystem.h
@@ -225,6 +225,34 @@ typedef enum {
 
 #endif
 
+#if ANDROID_VERSION >= 16
+typedef enum {
+    AUDIO_MODE_INVALID          = -2,
+    AUDIO_MODE_CURRENT          = -1,
+    AUDIO_MODE_NORMAL           = 0,
+    AUDIO_MODE_RINGTONE         = 1,
+    AUDIO_MODE_IN_CALL          = 2,
+    AUDIO_MODE_IN_COMMUNICATION = 3,
+
+    AUDIO_MODE_CNT,
+    AUDIO_MODE_MAX              = AUDIO_MODE_CNT - 1,
+} audio_mode_t;
+
+typedef enum {
+    AUDIO_OUTPUT_FLAG_NONE = 0x0,       // no attributes
+    AUDIO_OUTPUT_FLAG_DIRECT = 0x1,     // this output directly connects a track
+                                        // to one output stream: no software mixer
+    AUDIO_OUTPUT_FLAG_PRIMARY = 0x2,    // this output is the primary output of
+                                        // the device. It is unique and must be
+                                        // present. It is opened by default and
+                                        // receives routing, audio mode and volume
+                                        // controls related to voice calls.
+    AUDIO_OUTPUT_FLAG_FAST = 0x4,       // output supports "fast tracks",
+                                        // defined elsewhere
+    AUDIO_OUTPUT_FLAG_DEEP_BUFFER = 0x8 // use deep audio buffers
+} audio_output_flags_t;
+#endif
+
 typedef enum {
     /* output devices */      
     AUDIO_DEVICE_OUT_EARPIECE                  = 0x1,
@@ -246,6 +274,14 @@ typedef enum {
     AUDIO_DEVICE_OUT_FM_TX                     = 0x10000,
     AUDIO_DEVICE_OUT_DIRECTOUTPUT              = 0x20000,
     AUDIO_DEVICE_OUT_PROXY                     = 0x40000,
+
+   // << @adapted for sprd
+#if ANDROID_VERSION >= 16
+    AUDIO_DEVICE_OUT_FM_HEADSET                = 0x1000000,
+    AUDIO_DEVICE_OUT_FM_SPEAKER                = 0x2000000,
+#endif
+	// >>@
+	
     AUDIO_DEVICE_OUT_DEFAULT                   = 0x80000,
     AUDIO_DEVICE_OUT_ALL      = (AUDIO_DEVICE_OUT_EARPIECE |
                                  AUDIO_DEVICE_OUT_SPEAKER |
@@ -302,6 +338,11 @@ typedef enum {
     AUDIO_DEVICE_IN_ALL_SCO = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET,
 } audio_devices_t;
 
+//@adapted for sprd
+#if ANDROID_VERSION >= 16
+#define AUDIO_DEVICE_OUT_FM     AUDIO_DEVICE_OUT_FM_HEADSET
+#endif
+
 /* device connection states used for audio_policy->set_device_connection_state()
  *  */
 typedef enum {
@@ -649,7 +690,11 @@ public:
     //
     static status_t setDeviceConnectionState(audio_devices device, device_connection_state state, const char *device_address);
     static device_connection_state getDeviceConnectionState(audio_devices device, const char *device_address);
-    static status_t setPhoneState(int state);
+#if ANDROID_VERSION >= 16    
+	static status_t setPhoneState(audio_mode_t state);
+#else 
+	static status_t setPhoneState(int state);
+#endif	
     static status_t setRingerMode(uint32_t mode, uint32_t mask);
 #ifdef VANILLA_ANDROID
     static status_t setForceUse(force_use usage, forced_config config);
@@ -706,10 +751,17 @@ public:
                                       int indexMax);
     static status_t setStreamVolumeIndex(stream_type stream, int index);
     static status_t setStreamVolumeIndex(audio_stream_type_t stream, int index);
+	static status_t setStreamVolumeIndex(audio_stream_type_t stream,
+									 int index,
+									 audio_devices_t device);
     static status_t getStreamVolumeIndex(stream_type stream, int *index);
     static status_t getStreamVolumeIndex(audio_stream_type_t stream, int *index);
-
+    static status_t getStreamVolumeIndex(audio_stream_type_t stream,
+                                         int *index,
+                                         audio_devices_t device);
+										 
     static uint32_t getStrategyForStream(stream_type stream);
+	static audio_devices_t getDevicesForStream(audio_stream_type_t stream);
 
     static audio_io_handle_t getOutputForEffect(effect_descriptor_t *desc);
     static status_t registerEffect(effect_descriptor_t *desc,
diff --git a/media/libsydneyaudio/src/gonk/AudioTrack_JB.h b/media/libsydneyaudio/src/gonk/AudioTrack_JB.h
new file mode 100644
index 0000000..7ea0fcd
--- /dev/null
+++ b/media/libsydneyaudio/src/gonk/AudioTrack_JB.h
@@ -0,0 +1,552 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_AUDIOTRACK_H
+#define ANDROID_AUDIOTRACK_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include "IAudioFlinger.h"
+#include "IAudioTrack.h"
+#include "AudioSystem.h"
+
+#include <utils/RefBase.h>
+#include <utils/Errors.h>
+#include <binder/IInterface.h>
+#include <binder/IMemory.h>
+#include <cutils/sched_policy.h>
+#include <utils/threads.h>
+
+namespace android {
+
+// ----------------------------------------------------------------------------
+
+class audio_track_cblk_t;
+
+// ----------------------------------------------------------------------------
+
+class AudioTrack
+{
+public:
+    enum channel_index {
+        MONO   = 0,
+        LEFT   = 0,
+        RIGHT  = 1
+    };
+
+    /* Events used by AudioTrack callback function (audio_track_cblk_t).
+     */
+    enum event_type {
+        EVENT_MORE_DATA = 0,        // Request to write more data to PCM buffer.
+        EVENT_UNDERRUN = 1,         // PCM buffer underrun occured.
+        EVENT_LOOP_END = 2,         // Sample loop end was reached; playback restarted from loop start if loop count was not 0.
+        EVENT_MARKER = 3,           // Playback head is at the specified marker position (See setMarkerPosition()).
+        EVENT_NEW_POS = 4,          // Playback head is at a new position (See setPositionUpdatePeriod()).
+        EVENT_BUFFER_END = 5        // Playback head is at the end of the buffer.
+    };
+
+    /* Client should declare Buffer on the stack and pass address to obtainBuffer()
+     * and releaseBuffer().  See also callback_t for EVENT_MORE_DATA.
+     */
+
+    class Buffer
+    {
+    public:
+        enum {
+            MUTE    = 0x00000001
+        };
+        uint32_t    flags;        // 0 or MUTE
+        audio_format_t format; // but AUDIO_FORMAT_PCM_8_BIT -> AUDIO_FORMAT_PCM_16_BIT
+        // accessed directly by WebKit ANP callback
+        int         channelCount; // will be removed in the future, do not use
+
+        size_t      frameCount;   // number of sample frames corresponding to size;
+                                  // on input it is the number of frames desired,
+                                  // on output is the number of frames actually filled
+
+        size_t      size;         // input/output in byte units
+        union {
+            void*       raw;
+            short*      i16;    // signed 16-bit
+            int8_t*     i8;     // unsigned 8-bit, offset by 0x80
+        };
+    };
+
+
+    /* As a convenience, if a callback is supplied, a handler thread
+     * is automatically created with the appropriate priority. This thread
+     * invokes the callback when a new buffer becomes available or various conditions occur.
+     * Parameters:
+     *
+     * event:   type of event notified (see enum AudioTrack::event_type).
+     * user:    Pointer to context for use by the callback receiver.
+     * info:    Pointer to optional parameter according to event type:
+     *          - EVENT_MORE_DATA: pointer to AudioTrack::Buffer struct. The callback must not write
+     *            more bytes than indicated by 'size' field and update 'size' if fewer bytes are
+     *            written.
+     *          - EVENT_UNDERRUN: unused.
+     *          - EVENT_LOOP_END: pointer to an int indicating the number of loops remaining.
+     *          - EVENT_MARKER: pointer to an uint32_t containing the marker position in frames.
+     *          - EVENT_NEW_POS: pointer to an uint32_t containing the new position in frames.
+     *          - EVENT_BUFFER_END: unused.
+     */
+
+    typedef void (*callback_t)(int event, void* user, void *info);
+
+    /* Returns the minimum frame count required for the successful creation of
+     * an AudioTrack object.
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful operation
+     *  - NO_INIT: audio server or audio hardware not initialized
+     */
+
+     static status_t getMinFrameCount(int* frameCount,
+                                      audio_stream_type_t streamType = AUDIO_STREAM_DEFAULT,
+                                      uint32_t sampleRate = 0);
+
+    /* Constructs an uninitialized AudioTrack. No connection with
+     * AudioFlinger takes place.
+     */
+                        AudioTrack();
+
+    /* Creates an audio track and registers it with AudioFlinger.
+     * Once created, the track needs to be started before it can be used.
+     * Unspecified values are set to the audio hardware's current
+     * values.
+     *
+     * Parameters:
+     *
+     * streamType:         Select the type of audio stream this track is attached to
+     *                     (e.g. AUDIO_STREAM_MUSIC).
+     * sampleRate:         Track sampling rate in Hz.
+     * format:             Audio format (e.g AUDIO_FORMAT_PCM_16_BIT for signed
+     *                     16 bits per sample).
+     * channelMask:        Channel mask: see audio_channels_t.
+     * frameCount:         Minimum size of track PCM buffer in frames. This defines the
+     *                     latency of the track. The actual size selected by the AudioTrack could be
+     *                     larger if the requested size is not compatible with current audio HAL
+     *                     latency.  Zero means to use a default value.
+     * flags:              See comments on audio_output_flags_t in <system/audio.h>.
+     * cbf:                Callback function. If not null, this function is called periodically
+     *                     to request new PCM data.
+     * user:               Context for use by the callback receiver.
+     * notificationFrames: The callback function is called each time notificationFrames PCM
+     *                     frames have been consumed from track input buffer.
+     * sessionId:          Specific session ID, or zero to use default.
+     * threadCanCallJava:  Whether callbacks are made from an attached thread and thus can call JNI.
+     *                     If not present in parameter list, then fixed at false.
+     */
+
+                        AudioTrack( audio_stream_type_t streamType,
+                                    uint32_t sampleRate  = 0,
+                                    audio_format_t format = AUDIO_FORMAT_DEFAULT,
+                                    int channelMask      = 0,
+                                    int frameCount       = 0,
+                                    audio_output_flags_t flags = AUDIO_OUTPUT_FLAG_NONE,
+                                    callback_t cbf       = NULL,
+                                    void* user           = NULL,
+                                    int notificationFrames = 0,
+                                    int sessionId        = 0);
+
+                        // DEPRECATED
+                        explicit AudioTrack( int streamType,
+                                    uint32_t sampleRate  = 0,
+                                    int format = AUDIO_FORMAT_DEFAULT,
+                                    int channelMask      = 0,
+                                    int frameCount       = 0,
+                                    uint32_t flags       = (uint32_t) AUDIO_OUTPUT_FLAG_NONE,
+                                    callback_t cbf       = 0,
+                                    void* user           = 0,
+                                    int notificationFrames = 0,
+                                    int sessionId        = 0);
+
+    /* Creates an audio track and registers it with AudioFlinger. With this constructor,
+     * the PCM data to be rendered by AudioTrack is passed in a shared memory buffer
+     * identified by the argument sharedBuffer. This prototype is for static buffer playback.
+     * PCM data must be present in memory before the AudioTrack is started.
+     * The write() and flush() methods are not supported in this case.
+     * It is recommended to pass a callback function to be notified of playback end by an
+     * EVENT_UNDERRUN event.
+     */
+
+                        AudioTrack( audio_stream_type_t streamType,
+                                    uint32_t sampleRate = 0,
+                                    audio_format_t format = AUDIO_FORMAT_DEFAULT,
+                                    int channelMask     = 0,
+                                    const sp<IMemory>& sharedBuffer = 0,
+                                    audio_output_flags_t flags = AUDIO_OUTPUT_FLAG_NONE,
+                                    callback_t cbf      = NULL,
+                                    void* user          = NULL,
+                                    int notificationFrames = 0,
+                                    int sessionId       = 0);
+
+    /* Terminates the AudioTrack and unregisters it from AudioFlinger.
+     * Also destroys all resources associated with the AudioTrack.
+     */
+                        ~AudioTrack();
+
+
+    /* Initialize an uninitialized AudioTrack.
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful initialization
+     *  - INVALID_OPERATION: AudioTrack is already initialized
+     *  - BAD_VALUE: invalid parameter (channels, format, sampleRate...)
+     *  - NO_INIT: audio server or audio hardware not initialized
+     * */
+            status_t    set(audio_stream_type_t streamType = AUDIO_STREAM_DEFAULT,
+                            uint32_t sampleRate = 0,
+                            audio_format_t format = AUDIO_FORMAT_DEFAULT,
+                            int channelMask     = 0,
+                            int frameCount      = 0,
+                            audio_output_flags_t flags = AUDIO_OUTPUT_FLAG_NONE,
+                            callback_t cbf      = NULL,
+                            void* user          = NULL,
+                            int notificationFrames = 0,
+                            const sp<IMemory>& sharedBuffer = 0,
+                            bool threadCanCallJava = false,
+                            int sessionId       = 0);
+
+
+    /* Set mime type.
+     * AudioTrack can do different processing by mimes
+     * */
+            void        setMimeType(const char *mime);
+
+    /* Result of constructing the AudioTrack. This must be checked
+     * before using any AudioTrack API (except for set()), because using
+     * an uninitialized AudioTrack produces undefined results.
+     * See set() method above for possible return codes.
+     */
+            status_t    initCheck() const;
+
+    /* Returns this track's estimated latency in milliseconds.
+     * This includes the latency due to AudioTrack buffer size, AudioMixer (if any)
+     * and audio hardware driver.
+     */
+            uint32_t     latency() const;
+
+    /* getters, see constructors and set() */
+
+            audio_stream_type_t streamType() const;
+            audio_format_t format() const;
+            int         channelCount() const;
+            uint32_t    frameCount() const;
+
+    /* Return channelCount * (bit depth per channel / 8).
+     * channelCount is determined from channelMask, and bit depth comes from format.
+     */
+            size_t      frameSize() const;
+
+            sp<IMemory>& sharedBuffer();
+
+
+    /* After it's created the track is not active. Call start() to
+     * make it active. If set, the callback will start being called.
+     */
+            void        start();
+
+    /* Stop a track. If set, the callback will cease being called and
+     * obtainBuffer returns STOPPED. Note that obtainBuffer() still works
+     * and will fill up buffers until the pool is exhausted.
+     */
+            void        stop();
+            bool        stopped() const;
+
+    /* Flush a stopped track. All pending buffers are discarded.
+     * This function has no effect if the track is not stopped.
+     */
+            void        flush();
+
+    /* Pause a track. If set, the callback will cease being called and
+     * obtainBuffer returns STOPPED. Note that obtainBuffer() still works
+     * and will fill up buffers until the pool is exhausted.
+     */
+            void        pause();
+
+    /* Mute or unmute this track.
+     * While muted, the callback, if set, is still called.
+     */
+            void        mute(bool);
+            bool        muted() const;
+
+    /* Set volume for this track, mostly used for games' sound effects
+     * left and right volumes. Levels must be >= 0.0 and <= 1.0.
+     */
+            status_t    setVolume(float left, float right);
+            void        getVolume(float* left, float* right) const;
+
+    /* Set the send level for this track. An auxiliary effect should be attached
+     * to the track with attachEffect(). Level must be >= 0.0 and <= 1.0.
+     */
+            status_t    setAuxEffectSendLevel(float level);
+            void        getAuxEffectSendLevel(float* level) const;
+
+    /* Set sample rate for this track, mostly used for games' sound effects
+     */
+            status_t    setSampleRate(int sampleRate);
+            uint32_t    getSampleRate() const;
+
+    /* Enables looping and sets the start and end points of looping.
+     *
+     * Parameters:
+     *
+     * loopStart:   loop start expressed as the number of PCM frames played since AudioTrack start.
+     * loopEnd:     loop end expressed as the number of PCM frames played since AudioTrack start.
+     * loopCount:   number of loops to execute. Calling setLoop() with loopCount == 0 cancels any
+     *              pending or active loop. loopCount = -1 means infinite looping.
+     *
+     * For proper operation the following condition must be respected:
+     *          (loopEnd-loopStart) <= framecount()
+     */
+            status_t    setLoop(uint32_t loopStart, uint32_t loopEnd, int loopCount);
+
+    /* Sets marker position. When playback reaches the number of frames specified, a callback with
+     * event type EVENT_MARKER is called. Calling setMarkerPosition with marker == 0 cancels marker
+     * notification callback.
+     * If the AudioTrack has been opened with no callback function associated, the operation will fail.
+     *
+     * Parameters:
+     *
+     * marker:   marker position expressed in frames.
+     *
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful operation
+     *  - INVALID_OPERATION: the AudioTrack has no callback installed.
+     */
+            status_t    setMarkerPosition(uint32_t marker);
+            status_t    getMarkerPosition(uint32_t *marker) const;
+
+
+    /* Sets position update period. Every time the number of frames specified has been played,
+     * a callback with event type EVENT_NEW_POS is called.
+     * Calling setPositionUpdatePeriod with updatePeriod == 0 cancels new position notification
+     * callback.
+     * If the AudioTrack has been opened with no callback function associated, the operation will fail.
+     *
+     * Parameters:
+     *
+     * updatePeriod:  position update notification period expressed in frames.
+     *
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful operation
+     *  - INVALID_OPERATION: the AudioTrack has no callback installed.
+     */
+            status_t    setPositionUpdatePeriod(uint32_t updatePeriod);
+            status_t    getPositionUpdatePeriod(uint32_t *updatePeriod) const;
+
+    /* Sets playback head position within AudioTrack buffer. The new position is specified
+     * in number of frames.
+     * This method must be called with the AudioTrack in paused or stopped state.
+     * Note that the actual position set is <position> modulo the AudioTrack buffer size in frames.
+     * Therefore using this method makes sense only when playing a "static" audio buffer
+     * as opposed to streaming.
+     * The getPosition() method on the other hand returns the total number of frames played since
+     * playback start.
+     *
+     * Parameters:
+     *
+     * position:  New playback head position within AudioTrack buffer.
+     *
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful operation
+     *  - INVALID_OPERATION: the AudioTrack is not stopped.
+     *  - BAD_VALUE: The specified position is beyond the number of frames present in AudioTrack buffer
+     */
+            status_t    setPosition(uint32_t position);
+            status_t    getPosition(uint32_t *position);
+
+    /* Forces AudioTrack buffer full condition. When playing a static buffer, this method avoids
+     * rewriting the buffer before restarting playback after a stop.
+     * This method must be called with the AudioTrack in paused or stopped state.
+     *
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful operation
+     *  - INVALID_OPERATION: the AudioTrack is not stopped.
+     */
+            status_t    reload();
+
+    /* Returns a handle on the audio output used by this AudioTrack.
+     *
+     * Parameters:
+     *  none.
+     *
+     * Returned value:
+     *  handle on audio hardware output
+     */
+            audio_io_handle_t    getOutput();
+
+    /* Returns the unique session ID associated with this track.
+     *
+     * Parameters:
+     *  none.
+     *
+     * Returned value:
+     *  AudioTrack session ID.
+     */
+            int    getSessionId() const;
+
+    /* Attach track auxiliary output to specified effect. Use effectId = 0
+     * to detach track from effect.
+     *
+     * Parameters:
+     *
+     * effectId:  effectId obtained from AudioEffect::id().
+     *
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful operation
+     *  - INVALID_OPERATION: the effect is not an auxiliary effect.
+     *  - BAD_VALUE: The specified effect ID is invalid
+     */
+            status_t    attachAuxEffect(int effectId);
+
+    /* Obtains a buffer of "frameCount" frames. The buffer must be
+     * filled entirely, and then released with releaseBuffer().
+     * If the track is stopped, obtainBuffer() returns
+     * STOPPED instead of NO_ERROR as long as there are buffers available,
+     * at which point NO_MORE_BUFFERS is returned.
+     * Buffers will be returned until the pool (buffercount())
+     * is exhausted, at which point obtainBuffer() will either block
+     * or return WOULD_BLOCK depending on the value of the "blocking"
+     * parameter.
+     *
+     * Interpretation of waitCount:
+     *  +n  limits wait time to n * WAIT_PERIOD_MS,
+     *  -1  causes an (almost) infinite wait time,
+     *   0  non-blocking.
+     */
+
+        enum {
+            NO_MORE_BUFFERS = 0x80000001,   // same name in AudioFlinger.h, ok to be different value
+            STOPPED = 1
+        };
+
+            status_t    obtainBuffer(Buffer* audioBuffer, int32_t waitCount);
+
+    /* Release a filled buffer of "frameCount" frames for AudioFlinger to process. */
+            void        releaseBuffer(Buffer* audioBuffer);
+
+    /* As a convenience we provide a write() interface to the audio buffer.
+     * This is implemented on top of obtainBuffer/releaseBuffer. For best
+     * performance use callbacks. Returns actual number of bytes written >= 0,
+     * or one of the following negative status codes:
+     *      INVALID_OPERATION   AudioTrack is configured for shared buffer mode
+     *      BAD_VALUE           size is invalid
+     *      STOPPED             AudioTrack was stopped during the write
+     *      NO_MORE_BUFFERS     when obtainBuffer() returns same
+     *      or any other error code returned by IAudioTrack::start() or restoreTrack_l().
+     */
+            ssize_t     write(const void* buffer, size_t size);
+
+    /*
+     * Dumps the state of an audio track.
+     */
+            status_t dump(int fd, const Vector<String16>& args) const;
+
+protected:
+    /* copying audio tracks is not allowed */
+                        AudioTrack(const AudioTrack& other);
+            AudioTrack& operator = (const AudioTrack& other);
+
+    /* a small internal class to handle the callback */
+    class AudioTrackThread : public Thread
+    {
+    public:
+        AudioTrackThread(AudioTrack& receiver, bool bCanCallJava = false);
+
+        // Do not call Thread::requestExitAndWait() without first calling requestExit().
+        // Thread::requestExitAndWait() is not virtual, and the implementation doesn't do enough.
+        virtual void        requestExit();
+
+                void        pause();    // suspend thread from execution at next loop boundary
+                void        resume();   // allow thread to execute, if not requested to exit
+
+    private:
+        friend class AudioTrack;
+        virtual bool        threadLoop();
+        virtual status_t    readyToRun();
+        virtual void        onFirstRef();
+        AudioTrack& mReceiver;
+        ~AudioTrackThread();
+        Mutex               mMyLock;    // Thread::mLock is private
+        Condition           mMyCond;    // Thread::mThreadExitedCondition is private
+        bool                mPaused;    // whether thread is currently paused
+    };
+
+            // body of AudioTrackThread::threadLoop()
+            bool processAudioBuffer(const sp<AudioTrackThread>& thread);
+
+            status_t createTrack_l(audio_stream_type_t streamType,
+                                 uint32_t sampleRate,
+                                 audio_format_t format,
+                                 uint32_t channelMask,
+                                 int frameCount,
+                                 audio_output_flags_t flags,
+                                 const sp<IMemory>& sharedBuffer,
+                                 audio_io_handle_t output);
+            void flush_l();
+            status_t setLoop_l(uint32_t loopStart, uint32_t loopEnd, int loopCount);
+            audio_io_handle_t getOutput_l();
+            status_t restoreTrack_l(audio_track_cblk_t*& cblk, bool fromStart);
+            bool stopped_l() const { return !mActive; }
+
+    sp<IAudioTrack>         mAudioTrack;
+    sp<IMemory>             mCblkMemory;
+    sp<AudioTrackThread>    mAudioTrackThread;
+
+    float                   mVolume[2];
+    float                   mSendLevel;
+    uint32_t                mFrameCount;
+
+    audio_track_cblk_t*     mCblk;
+    audio_format_t          mFormat;
+    audio_stream_type_t     mStreamType;
+    uint8_t                 mChannelCount;
+    uint8_t                 mMuted;
+    uint8_t                 mReserved;
+    uint32_t                mChannelMask;
+    status_t                mStatus;
+    uint32_t                mLatency;
+
+    bool                    mActive;                // protected by mLock
+
+    callback_t              mCbf;                   // callback handler for events, or NULL
+    void*                   mUserData;
+    uint32_t                mNotificationFramesReq; // requested number of frames between each notification callback
+    uint32_t                mNotificationFramesAct; // actual number of frames between each notification callback
+    sp<IMemory>             mSharedBuffer;
+    int                     mLoopCount;
+    uint32_t                mRemainingFrames;
+    uint32_t                mMarkerPosition;
+    bool                    mMarkerReached;
+    uint32_t                mNewPosition;
+    uint32_t                mUpdatePeriod;
+    bool                    mFlushed; // FIXME will be made obsolete by making flush() synchronous
+    audio_output_flags_t    mFlags;
+    int                     mSessionId;
+    int                     mAuxEffectId;
+    mutable Mutex           mLock;
+    status_t                mRestoreStatus;
+    bool                    mIsTimed;
+    int                     mPreviousPriority;          // before start()
+    SchedPolicy             mPreviousSchedulingGroup;
+
+    String8                 mMimeType; // media format of this track.
+};
+
+}; // namespace android
+
+#endif // ANDROID_AUDIOTRACK_H
diff --git a/media/libsydneyaudio/src/gonk/EffectApi.h b/media/libsydneyaudio/src/gonk/EffectApi.h
index b97c22e..ca92d2b 100644
--- a/media/libsydneyaudio/src/gonk/EffectApi.h
+++ b/media/libsydneyaudio/src/gonk/EffectApi.h
@@ -600,12 +600,15 @@ enum audio_device_e {
     DEVICE_EXTERNAL_SPEAKER = 0x800             // external speaker (stereo and High quality)
 };
 
+
 // Audio mode
+#if ANDROID_VERSION < 16
 enum audio_mode_e {
     AUDIO_MODE_NORMAL,      // device idle
     AUDIO_MODE_RINGTONE,    // device ringing
     AUDIO_MODE_IN_CALL      // audio call connected (VoIP or telephony)
 };
+#endif
 
 // Values for "accessMode" field of buffer_config_t:
 //   overwrite, read only, accumulate (read/modify/write)
diff --git a/media/libsydneyaudio/src/sydney_audio_gonk.cpp b/media/libsydneyaudio/src/sydney_audio_gonk.cpp
index 25b681a..c11e2b5 100644
--- a/media/libsydneyaudio/src/sydney_audio_gonk.cpp
+++ b/media/libsydneyaudio/src/sydney_audio_gonk.cpp
@@ -9,7 +9,11 @@ extern "C" {
 #include "sydney_audio.h"
 }
 
+#if ANDROID_VERSION >= 16
+#include "gonk/AudioTrack_JB.h"
+#else
 #include "gonk/AudioTrack.h"
+#endif
 #include "android/log.h"
 
 #if defined(DEBUG) || defined(FORCE_ALOG)
@@ -164,7 +168,7 @@ sa_stream_open(sa_stream_t *s) {
   int frameCount;
   /* frameCount returned here is already twice of minFrameCount and calculated
    * inside AudioTrack::getMinFrameCount() */
-  if (AudioTrack::getMinFrameCount(&frameCount, s->streamType,
+  if (AudioTrack::getMinFrameCount(&frameCount, static_cast<audio_stream_type_t>(s->streamType),
                                    s->rate) != NO_ERROR) {
     return SA_ERROR_INVALID;
   }
diff --git a/media/omx-plugin/Makefile.in b/media/omx-plugin/Makefile.in
index d498d35..41f3ebe 100644
--- a/media/omx-plugin/Makefile.in
+++ b/media/omx-plugin/Makefile.in
@@ -71,6 +71,12 @@ INCLUDES        += \
                 -I$(ANDROID_SOURCE)/system/core/include \
                 -I$(ANDROID_SOURCE)/hardware/libhardware/include \
                 $(NULL)
+INCLUDES        += \
+                -I$(ANDROID_SOURCE)/frameworks/native/include/media/openmax \
+                -I$(ANDROID_SOURCE)/frameworks/av/include/media/ \
+                -I$(ANDROID_SOURCE)/frameworks/av/include/media/stagefright \
+                -I$(ANDROID_SOURCE)/frameworks/av/media/libstagefright/include \
+                $(NULL)
 else
 EXTRA_DSO_LDOPTS += \
 		-L$(DEPTH)/media/omx-plugin/lib/ics/libutils \
diff --git a/netwerk/protocol/device/gonk/CameraHardwareInterface.h b/netwerk/protocol/device/gonk/CameraHardwareInterface.h
index c60739c..865a5df 100644
--- a/netwerk/protocol/device/gonk/CameraHardwareInterface.h
+++ b/netwerk/protocol/device/gonk/CameraHardwareInterface.h
@@ -19,7 +19,7 @@
 
 #include <binder/IMemory.h>
 #include <utils/RefBase.h>
-#include <surfaceflinger/ISurface.h>
+#include <gui/ISurface.h>
 #include "Camera.h"
 #include "CameraParameters.h"
 
diff --git a/toolkit/library/Makefile.in b/toolkit/library/Makefile.in
index 7ec916b..b69a924 100644
--- a/toolkit/library/Makefile.in
+++ b/toolkit/library/Makefile.in
@@ -449,6 +449,7 @@ OS_LIBS += \
   -lstagefright_omx \
   -lbinder \
   -lgui \
+  -lz \
   $(NULL)
 endif
 
diff --git a/widget/gonk/HWComposer.cpp b/widget/gonk/HWComposer.cpp
index 12f90a3..4d6fb76 100644
--- a/widget/gonk/HWComposer.cpp
+++ b/widget/gonk/HWComposer.cpp
@@ -19,6 +19,11 @@
 #include <hardware/hardware.h>
 #include <EGL/egl.h>
 
+#if ANDROID_VERSION >= 16
+#define LOGW_IF ALOGW_IF
+#define LOGE_IF ALOGE_IF
+#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
diff --git a/widget/gonk/libui/InputDispatcher.cpp b/widget/gonk/libui/InputDispatcher.cpp
index 3ec3727..ce72ad4 100644
--- a/widget/gonk/libui/InputDispatcher.cpp
+++ b/widget/gonk/libui/InputDispatcher.cpp
@@ -52,9 +52,11 @@
 #define DEBUG_HOVER 0
 
 #include "InputDispatcher.h"
-
+#if ANDROID_VERSION < 16
 #include <ui/PowerManager.h>
-
+#else
+#include <androidfw/PowerManager.h>
+#endif
 #include <stddef.h>
 #include <unistd.h>
 #include <errno.h>
@@ -63,6 +65,7 @@
 #define INDENT "  "
 #define INDENT2 "    "
 
+
 namespace android {
 
 // Default input dispatching timeout if there is no focused application or paused window
diff --git a/widget/gonk/nsWindow.cpp b/widget/gonk/nsWindow.cpp
index 54c4010..20b2b2b 100644
--- a/widget/gonk/nsWindow.cpp
+++ b/widget/gonk/nsWindow.cpp
@@ -20,6 +20,9 @@
 
 #include "android/log.h"
 #include "ui/FramebufferNativeWindow.h"
+#if ANDROID_VERSION >= 16
+#include "ui/PixelFormat.h"
+#endif
 
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/Hal.h"
@@ -716,9 +719,9 @@ static uint32_t
 ColorDepth()
 {
     switch (NativeWindow()->getDevice()->format) {
-    case GGL_PIXEL_FORMAT_RGB_565:
+    case android::PIXEL_FORMAT_RGB_565:
         return 16;
-    case GGL_PIXEL_FORMAT_RGBA_8888:
+    case android::PIXEL_FORMAT_RGBA_8888:
         return 32;
     }
     return 24; // GGL_PIXEL_FORMAT_RGBX_8888
